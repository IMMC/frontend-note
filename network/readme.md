# url 输入到打开网页全过程

## dns 解析

要实现计算机双方通讯，必须就要知道通讯双方的地址。我们一般用的是域名。域名可以当做是一个别名。真正有效的是 ip 地址。互联网是有许许多多的子网络构成的，而通过 ip 地址的形式来划分不同的子网络，以及确定具体的子网络。

### dns 包 包含的数据

1. 目标域名的 ip 地址
2. 管理目标域名 dns 的解析服务器 （ns 记录）
3. 解析服务器的 ip 地址 （a 记录）

### dns 服务器地址

现在接入网络的设备，一开始是不知道 dns 服务器的地址的。现在大多数情况，是通过 DHCP 协议，来为接入网络的设配分配 ip 地址和 dns 地址。

#### dhcp 协议

dhcp 协议动态分配 ip 地址。使用的是 udp 协议。实现原理是，在新设备接入网络时，发送一个 dhcp 包，包内容主要是，目标 ip 地址，由于这里刚接入网络，并不知道网关的 ip 地址，只能包含一个广播的 ip 地址，和广播的 mac 地址。网关接收到这个包后，做出响应，为接入的设备分配 ip 地址，以及 dns 服务器的地址。

### dns 分级查询

dns 服务器如何知道域名的 ip 地址呢？答案是分级查询。

域名服务器分 3 级： 根服务器，顶级域名服务器，次级域名服务器。
一般来说我们的域名是 `www.baidu.com`。 但其实这是缩写，完整的应该是 `www.baidu.com.root`. `.root` 表示这是一个根域名。接下来就是`.com`, 表示一个顶级域名。`.baidu` 表示一个次级域名，可以用户自己注册。`www` 是用户自己分配的三级域名。

所以在分级查询的过程：

1. 从根服务器获得顶级域名的 ns 记录和 a 记录
2. 从顶级域名服务器获得次级域名服务器的 ns 记录和 a 记录
3. 次级域名服务器响应 3 级域名分配的 ip 地址

dns 查询，存在转发形式和非转发形式。转发形式在本地或者网络内 dns 服务器处理不了时，就向上级 dns 服务器转发处理。如果是非转发形式就直接进行前面所说的 3 级查询。一个这样的递归过程，来实现 dns 解析。

### 为什么 dns 使用 udp

实际上，dns 并不是完全使用 udp 协议，在区域内，同步 dns 记录，为了稳定性，还是会使用 tcp 协议。

在最开始设计 dns 协议是，确实是使用 udp 协议来进行传输的，但是后面数据传输量的增加，dns 需要 tcp 的分包，重试机制，来保证数据的可靠性。

### dns 劫持

恶意篡改 dns 解析记录，使得用户得到错误的 dns 解析地址。

## 建立 http 连接

在前一步通过 dns 解析后，拿到了 ip 地址，就需要建立起连接，以此来建立通讯了。

### tcp 协议

http 是使用 tcp 协议进行传输的。tcp 是面向连接的，可靠的字节流服务。
tcp 是可靠的传输协议。分包，自动重组数据包，超时重传。

#### tcp 三次握手

为了保证，通讯双方都具备发送和接收的能力，需要进行三次握手。

1. 客户端发送建立连接的包，SYN 置为 1，并设置序列号 seq, 这个 seq 随机产生。 SYN 是同步序列号，表示建立连接请求（SYN 同步序列号），客户端进入 SYN_SEND 状态。
2. 服务端响应确认收到连接的包，此时响应 SYN 置 1， ACK 置 1，并且返回自己的一个 seq, 并且响应一个 acknumber, 就是客户端发送的 seq + 1。服务端进入 SYN_RECV 状态
3. 客户端收到确认连接的包还需要向服务端发送一个确认收到确认包的包，ACK 置 1，acknumber 是服务端的 seq + 1, 并带上自己的 seq. 客户端和服务端都进入 ESTABLISHED 状态

#### tcp 四次挥手

当客户端发送断开连接的请求是，只是表示，自己没有数据发送给服务端了，但是并不表示服务端已经没有数据要发送给客户端了。所以服务端收到关闭连接的请求后，会先向客户端确认已收到，再向客户端发送关闭连接的请求。客户端再发送确认关闭的请求，所以这里用到四次挥手。

1. 客户端把 FIN 置 1, 带上一个 ACKnumber, 并带上连接序列号 seq, 客户端进入 FIN_WAIT_1 状态
2. 服务端收到关闭连接请求后，发送确认收到的包，包含 ACKnumber 是 seq + 1, 和 seq。客户端进入 FIN_WAT_2 状态。服务端进入 CLOSE_WAIT 状态
3. 服务端确认所有数据都发送完成后，向客户端发送关闭请求。把 FIN 置 1，带上序列号 seq,并进入 LAST_ACK 状态.
4. 客户端收到第三次挥手的包后，进入到 TIME_WAIT 阶段，并发送最后一次确认的包，带上 ACKnumber. 服务端进入 CLOSE 状态，客户端等待 2 个等待时间后，也进入 CLOSE 状态。 最后等待 2MSL 是为了保证最后一次断开确认能完成。

#### tcp 和 udp 的区别

1. tcp 是面向连接的，udp 无连接，尽最大可能交付。tcp 保证数据完整性，udp 不保证。
2. tcp 是字节流传输，把上层协议数据看成字节流分包。udp 是面向报文传输，直接发送报文。
